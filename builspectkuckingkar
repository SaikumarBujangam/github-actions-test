import os
import boto3
import time
from alight.foundation.util.logging.standardlogger import StandardLogger

class PipelineCheck:
    def __init__(self):
        self.logger = StandardLogger().getDefaultLogger()
        self.codepipeline = boto3.client('codepipeline')
        self.app_subject_area = os.environ.get('APP_SUBJECT_AREA')
        self.lifecycle_env = os.environ.get('lifecycle_env')

    def check_pipeline_status(self, wait_time=30, max_attempts=120):
        pipeline_name_prefix = "adl-com-{}".format(self.lifecycle_env)
        pipeline_suffix = "codepipeline"
        adjusted_app_subject_area = self.app_subject_area.replace("adl-", "")
        pipeline_name = "{}-{}-{}".format(pipeline_name_prefix, adjusted_app_subject_area, pipeline_suffix)
        attempt = 0
        while attempt < max_attempts:
            response = self.codepipeline.get_pipeline_state(name=pipeline_name)
            stages = response['stageStates']
            all_statuses = []  # This will collect the status of all stages per attempt

            for stage in stages:
                stage_name = stage['stageName']
                latest_execution = stage.get('latestExecution', {})
                status = latest_execution.get('status', 'UNKNOWN')

                all_statuses.append((stage_name, status))
                # Log the status of each stage
                self.logger.info("Pipeline is in stage '{}' with status '{}'.".format(stage_name, status))
                
            # After checking all stages, decide if you need to wait more based on your criteria
            final_statuses = ['Succeeded', 'Failed', 'Stopped']
            if all(status in final_statuses for _, status in all_statuses):
                # If all stages are in a final state, return the collected statuses
                return all_statuses
            
            # Optional: log that the pipeline execution is still in progress if not all stages are final
            if any(status not in final_statuses for _, status in all_statuses):
                self.logger.info("Pipeline execution is still in progress . . .")
            
            time.sleep(wait_time)
            attempt += 1

        # Return the collected statuses if max_attempts is reached without all stages completing
        return all_statuses
