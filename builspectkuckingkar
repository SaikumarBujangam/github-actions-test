import psycopg2
import sys
import os
from alight.foundation.postgres.postgresdataapi import PostgresDataAPI
from alight.foundation.util.argparsebuilder import GenerateParser
from alight.foundation.util.logging.standardlogger import StandardLogger
from alight.foundation.util.stringutil import StringUtil
from alight.foundation.redshift.utils.replacement import DDLVariableReplacer

if __name__ == "__main__":
    logger = StandardLogger().getDefaultLogger()
    try:
        command_args = GenerateParser(supports_duplicate_parameters=True).build()
        logger.info("Running {} file on host: {}. database: {}".format(
            command_args.artifactDdlFile, command_args.dbHost, command_args.dbName))

        db_username = os.environ.get('POSTGRES_DB_USER_NAME')
        db_password = os.environ.get('POSTGRES_DB_PASSWORD')

        # Flag to allow potentially destructive operations
        allow_destructive_operations = command_args.allowDestructiveOperations.lower() == 'true'

        postgres_api = PostgresDataAPI(
            db_name=command_args.dbName,
            db_user_name=db_username,
            db_host=command_args.dbHost,
            db_port=command_args.dbPort,
            db_password=db_password,
            allow_destructive_operations=allow_destructive_operations  # Pass the flag
        )

        su = StringUtil()
        replacement_params = su.property_list_to_dict(input_list=command_args.cicdVar)
        replacer = DDLVariableReplacer(parameter_dict=replacement_params)
        with open(command_args.artifactDdlFile) as ddl_file:
            ddl_statement = replacer.replace(ddl_file.read())
            for schema_name in command_args.dbSchemaList.split(","):
                execution_statement = []
                if schema_name != "EMBEDDED":
                    execution_statement.append("set search_path to {}".format(schema_name))
                execution_statement.append(ddl_statement)

            postgres_api.execute_sql(sql_statement=";\n".join(execution_statement))

    except Exception as e:
        logger.error(e)


import psycopg2
from alight.foundation.util.logging.standardlogger import StandardLogger

class PostgresDataAPI:
    logger = StandardLogger().getDefaultLogger()

    def __init__(self, db_name=None, db_user_name=None, db_host=None, db_port=5432, db_password=None, allow_destructive_operations=False):
        self._conn = None
        self._cursor = None
        self._db_name = db_name
        self._db_user_name = db_user_name
        self._db_host = db_host
        self._db_port = db_port
        self._db_password = db_password
        self._allow_destructive_operations = allow_destructive_operations  # Added parameter

    def connect(self):
        try:
            connection_params = {
                "dbname": self._db_name,
                "user": self._db_user_name,
                "password": self._db_password,
                "host": self._db_host,
                "port": self._db_port
            }
            self._conn = psycopg2.connect(**connection_params)
            self.logger.info("Connected to the host: {}, database: {}".format(self._db_host, self._db_name))
            self._cursor = self._conn.cursor()
        except Exception as e:
            self.logger.error(f"Error connecting to the database: {e}")
            raise

    def execute_sql(self, sql_statement):
        try:
            if not self._cursor or self._cursor.closed:
                self.connect()

            # Check if potentially destructive operations are allowed
            if not self._allow_destructive_operations and self._contains_destructive_operations(sql_statement):
                raise ValueError("Potentially destructive operations are not allowed without confirmation.")

            self._cursor.execute(sql_statement)
            self._conn.commit()
            self.logger.info("SQL Statement executed successfully.")
            return "FINISHED"
        except Exception as e:
            self.logger.error("Error executing SQL statement: {}".format(e))
            return "FAILED"
        finally:
            self.close_connection()

    def close_connection(self):
        if self._cursor:
            self._cursor.close()
        if self._conn:
            self._conn.close()

    def _contains_destructive_operations(self, sql_statement):
        destructive_keywords = ['drop', 'delete']
        normalized_sql = sql_statement.lower()
        return any(keyword in normalized_sql for keyword in destructive_keywords)
