import psycopg2
import time
import uuid
from alight.foundation.util.logging.standardlogger import StandardLogger

class PostgresPostgresDataAPI:
    logger = StandardLogger().getDefaultLogger()

    def __init__(self, db_name=None, db_user_name=None, db_host=None, db_port=5432, db_password=None):
        self._conn = None
        self._cursor = None
        self._db_name = db_name
        self._db_user_name = db_user_name
        self._db_host = db_host
        self._db_port = db_port
        self._db_password = db_password

    def connect(self):
        try:
            connection_params = {
                "dbname": self._db_name,
                "user": self._db_user_name,
                "password": self._db_password,
                "host": self._db_host,
                "port": self._db_port
            }
            self._conn = psycopg2.connect(**connection_params)
            self._cursor = self._conn.cursor()
        except Exception as e:
            self.logger.error(f"Error connecting to the database: {e}")
            raise

    def execute_sql(self, sql_statement, retry_attempts=500, retry_interval=1, with_event=True, parameters=None):
        try:
            if parameters is None:
                self._cursor.execute(sql_statement)
            else:
                self._cursor.execute(sql_statement, parameters)

            query_id = str(uuid.uuid4())
            status = "N/A"
            # Create a temporary table for the current session in the test_cicd schema
            temp_table_name = "temp_query_status"
            self._cursor.execute(f"CREATE TEMPORARY TABLE test_cicd.{temp_table_name} (query_id UUID, status VARCHAR);")
            # Store the status information in the temporary table
            self._cursor.execute(f"INSERT INTO test_cicd.{temp_table_name} (query_id, status) VALUES (%s, %s);", (query_id, status))
            self._conn.commit()

            current_attempt = 0
            while current_attempt < retry_attempts:
                status = self.status_check(query_id)
                if status in ("FAILED", "FINISHED"):
                    self.logger.info("status is: {}".format(status))
                    break
                time.sleep(retry_interval)
            return query_id, status
        except Exception as e:
            self.logger.error("Error executing SQL statement: {}".format(e))
            raise
        finally:
            # Ensure to close the temporary table at the end
            try:
                self._cursor.execute(f"DROP TABLE IF EXISTS test_cicd.{temp_table_name};")
                self._conn.commit()
            except Exception as drop_error:
                self.logger.error("Error dropping temporary table: {}".format(drop_error))

    def status_check(self, query_id):
        try:
            # Retrieve the status information from the temporary table in the test_cicd schema
            temp_table_name = "temp_query_status"
            self._cursor.execute(f"SELECT status FROM test_cicd.{temp_table_name} WHERE query_id = %s;", (query_id,))
            result = self._cursor.fetchone()

            if result:
                return result[0]  # Assuming 'status' is the first column in the result
            else:
                self.logger.warning("Warning: Status not found for query_id {}".format(query_id))
                return "UNKNOWN"  # Status not found in the temporary table

        except Exception as e:
            self.logger.error("Error checking status for query_id {}: {}".format(query_id, e))
            return "ERROR"
        finally:
            # Ensure to close the temporary table at the end
            try:
                self._cursor.execute(f"DROP TABLE IF EXISTS test_cicd.{temp_table_name};")
                self._conn.commit()
            except Exception as drop_error:
                self.logger.error("Error dropping temporary table: {}".format(drop_error))

    def close_connection(self):
        if self._cursor:
            self._cursor.close()
        if self._conn:
            self._conn.close()
