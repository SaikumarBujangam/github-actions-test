import os
import boto3
import time
from alight.foundation.util.logging.standardlogger import StandardLogger

class PipelineCheck:
    def __init__(self):
        self.logger = StandardLogger().getDefaultLogger()
        self.codepipeline = boto3.client('codepipeline')
        self.app_subject_area = os.environ.get('APP_SUBJECT_AREA')
        if self.app_subject_area is None:
            raise ValueError("APP_SUBJECT_AREA environment variable is not set")
        self.lifecycle_env = os.environ.get('lifecycle_env')
        if self.lifecycle_env is None:
            raise ValueError("lifecycle_env environment variable is not set")
        self.latest_execution_id = None  # Placeholder for storing the latest pipeline execution ID

    def check_pipeline_status(self, wait_time=30, max_attempts=120):
        pipeline_name_prefix = "adl-com-{}".format(self.lifecycle_env)
        pipeline_suffix = "codepipeline"
        adjusted_app_subject_area = self.app_subject_area.replace("adl-", "")
        pipeline_name = "{}-{}-{}".format(pipeline_name_prefix, adjusted_app_subject_area, pipeline_suffix)
        attempt = 0
        while attempt < max_attempts:
            response = self.codepipeline.list_pipeline_executions(pipelineName=pipeline_name, maxResults=1)
            if not response['pipelineExecutionSummaries']:
                raise Exception("No executions found for the pipeline.")
            latest_execution = response['pipelineExecutionSummaries'][0]
            execution_id = latest_execution['pipelineExecutionId']
            self.latest_execution_id = execution_id  # Store the latest execution ID

            execution_details = self.codepipeline.get_pipeline_execution(pipelineName=pipeline_name, pipelineExecutionId=execution_id)
            status = execution_details['pipelineExecution']['status']

            if status in ['Succeeded', 'Failed', 'Stopped']:
                if status == 'Failed':
                    # If the pipeline failed, attempt to log failure details
                    failure_reasons = self.get_failure_details(pipeline_name)
                    for reason in failure_reasons:
                        self.logger.error(reason)
                return status
            else:
                time.sleep(wait_time)
                attempt += 1

        raise TimeoutError("Max attempts reached while waiting for pipeline to complete.")

    def get_failure_details(self, pipeline_name):
        """Fetch details on why a pipeline execution failed."""
        try:
            response = self.codepipeline.get_pipeline_execution(pipelineName=pipeline_name, pipelineExecutionId=self.latest_execution_id)
            details = []

            stages = response['pipelineExecution']['pipelineExecutionStages']
            for stage in stages:
                stage_name = stage['stageName']
                actions = stage['actionStates']
                for action in actions:
                    if 'latestExecution' in action and action['latestExecution']['status'] == 'Failed':
                        error_details = action['latestExecution'].get('errorDetails', {})
                        message = error_details.get('message', 'No error message provided.')
                        details.append("Stage '{0}' failed: {1}".format(stage_name, message))

            return details if details else ["No detailed error message found."]
        except Exception as e:
            self.logger.error("Failed to fetch pipeline failure details: {0}".format(e))
            return []
