import logging
from alight.foundation.util.logging.logger import Logging4PythonConfig

# This acts sort of like a singleton, but with a caveate. It is expected that the
# first item to call this will supply a name -- which, will become the name of the
# logger -- which translates into the cloudwatch stream name
# There is still some clean-up to do, and Logging4PythonConfig perhaps should really be
# called ElementLoggerConfig, with the understanding that it "supports" cloudwatch
# This can be done later.
# The double-underscore dictionary and method prevents the config loader from loading and
# re-reading the config file, as well as making the additional call to Logging4PythonConfig
# which would make an additional call to AWS Cloudwatch if it exists in the logging config.
# Initializing self.__logger is required, it cannot be within any conditional. This is OK
# because logging.getLogger("name") will return a logger with that name if it already exists,
# kind of like a singleton...
class StandardLogger():
    __singleton_dict = {}

    def __make_singleton(self, logger_class='consolelogger', logger_group_name='default', logger_config_file=None):
        if 'logger_name' not in self.__singleton_dict:
            self.__singleton_dict['logger_name'] = logger_class
            self.__singleton_dict['logger_group_name'] = logger_group_name

        if logger_class is not None and 'logger_config_done' not in self.__singleton_dict:
            Logging4PythonConfig(logger_group_name=self.__singleton_dict['logger_group_name'],
                                 logger_name=logger_class, logging_config_file=logger_config_file)
            self.__singleton_dict['logger_config_done'] = True

    def __init__(self, logger_class='consolelogger', logger_group_name='default', logger_config_file=None):
        self.__make_singleton(logger_class, logger_group_name, logger_config_file)

    def getDefaultLogger(self):
        return logging.getLogger(self.__singleton_dict['logger_name'])
